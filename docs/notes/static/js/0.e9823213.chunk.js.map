{"version":3,"sources":["../../src/util/constants.ts","../../src/util/errors.ts","../../src/api/common.ts","../../src/api/create-installation-request.ts","../../src/util/sleep.ts","../../src/helpers/generate-fid.ts","../../src/helpers/buffer-to-base64-url-safe.ts","../../src/util/get-key.ts","../../src/helpers/fid-changed.ts","../../src/helpers/idb-manager.ts","../../src/index.ts","../../src/helpers/get-installation-entry.ts","../../src/api/generate-auth-token-request.ts","../../src/helpers/refresh-auth-token.ts","../../src/functions/get-token.ts","../../src/api/delete-installation-request.ts","../../src/functions/on-id-change.ts","../../src/helpers/extract-app-config.ts","../../src/functions/get-id.ts","../../src/functions/delete-installation.ts","../node_modules/idb/build/idb.js"],"names":["PENDING_TIMEOUT_MS","PACKAGE_VERSION","INTERNAL_AUTH_VERSION","TOKEN_EXPIRATION_BUFFER","ERROR_DESCRIPTION_MAP","ERROR_FACTORY","isServerError","error","code","includes","getInstallationsEndpoint","INSTALLATIONS_API_URL","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","replace","creationTime","Date","now","getErrorFromResponse","requestName","json","responseJson","errorData","create","serverCode","serverMessage","message","serverStatus","status","getHeaders","apiKey","Headers","Accept","getHeadersWithAuth","appConfig","refreshToken","headers","append","getAuthorizationHeader","retryIfServerError","fn","result","createInstallationRequest","fid","endpoint","body","authVersion","appId","sdkVersion","request","method","JSON","stringify","fetch","ok","responseValue","registrationStatus","authToken","sleep","ms","Promise","resolve","setTimeout","VALID_FID_PATTERN","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","array","btoa","String","fromCharCode","substr","encode","test","getKey","appName","fidChangeCallbacks","Map","fidChanged","key","callFidChangeCallbacks","channel","getBroadcastChannel","postMessage","closeBroadcastChannel","broadcastFidChange","callbacks","get","callback","broadcastChannel","BroadcastChannel","onmessage","e","data","size","close","instance","OBJECT_STORE_NAME","dbPromise","getDbPromise","upgradeDB","oldVersion","createObjectStore","set","value","db","tx","transaction","objectStore","oldValue","put","complete","remove","delete","update","updateFn","store","undefined","newValue","getInstallationEntry","oldEntry","installationEntry","clearTimedOutRequest","updateOrCreateInstallationEntry","entryWithPromise","navigator","onLine","registrationPromise","reject","inProgressEntry","registrationTime","registeredInstallationEntry","customData","registerInstallation","waitUntilFidRegistration","triggerRegistrationIfNecessary","updateInstallationRequest","entry","generateAuthTokenRequest","platformLoggerProvider","getGenerateAuthTokenEndpoint","platformLogger","getImmediate","optional","getPlatformInfoString","installation","refreshAuthToken","dependencies","forceRefresh","isEntryRegistered","oldAuthToken","isAuthTokenExpired","isAuthTokenValid","tokenPromise","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","completeInstallationRegistration","deleteInstallationRequest","getDeleteEndpoint","callbackSet","Set","add","addCallback","removeCallback","getMissingValueError","valueName","INTERNAL","registerComponent","container","app","getProvider","options","name","keyName","projectId","extractAppConfig","getId","catch","console","getToken","deleteInstallation","onIdChange","registerVersion","version","exports","toArray","arr","Array","prototype","slice","call","promisifyRequest","onsuccess","onerror","promisifyRequestCall","obj","args","p","apply","then","promisifyCursorRequestCall","Cursor","proxyProperties","ProxyClass","targetProp","properties","forEach","prop","Object","defineProperty","this","val","proxyRequestMethods","Constructor","arguments","proxyMethods","proxyCursorRequestMethods","Index","index","_index","cursor","_cursor","_request","ObjectStore","_store","Transaction","idbTransaction","_tx","oncomplete","onabort","UpgradeDB","_db","DB","openDb","upgradeCallback","indexedDB","onupgradeneeded","event","deleteDb","IDBIndex","IDBCursor","methodName","createIndex","IDBObjectStore","IDBTransaction","IDBDatabase","funcName","length","nativeObject","getAll","query","count","items","iterateCursor","push","continue","factory"],"mappings":"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","file":"static/js/0.e9823213.chunk.js","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { version } from '../../package.json';\n\nexport const PENDING_TIMEOUT_MS = 10000;\n\nexport const PACKAGE_VERSION = `w:${version}`;\nexport const INTERNAL_AUTH_VERSION = 'FIS_v2';\n\nexport const INSTALLATIONS_API_URL =\n  'https://firebaseinstallations.googleapis.com/v1';\n\nexport const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\n\nexport const SERVICE = 'installations';\nexport const SERVICE_NAME = 'Installations';\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { SERVICE, SERVICE_NAME } from './constants';\n\nexport const enum ErrorCode {\n  MISSING_APP_CONFIG_VALUES = 'missing-app-config-values',\n  NOT_REGISTERED = 'not-registered',\n  INSTALLATION_NOT_FOUND = 'installation-not-found',\n  REQUEST_FAILED = 'request-failed',\n  APP_OFFLINE = 'app-offline',\n  DELETE_PENDING_REGISTRATION = 'delete-pending-registration'\n}\n\nconst ERROR_DESCRIPTION_MAP: { readonly [key in ErrorCode]: string } = {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]:\n    'Missing App configuration value: \"{$valueName}\"',\n  [ErrorCode.NOT_REGISTERED]: 'Firebase Installation is not registered.',\n  [ErrorCode.INSTALLATION_NOT_FOUND]: 'Firebase Installation not found.',\n  [ErrorCode.REQUEST_FAILED]:\n    '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n  [ErrorCode.APP_OFFLINE]: 'Could not process request. Application offline.',\n  [ErrorCode.DELETE_PENDING_REGISTRATION]:\n    \"Can't delete installation while there is a pending registration request.\"\n};\n\ninterface ErrorParams {\n  [ErrorCode.MISSING_APP_CONFIG_VALUES]: {\n    valueName: string;\n  };\n  [ErrorCode.REQUEST_FAILED]: {\n    requestName: string;\n    [index: string]: string | number; // to make Typescript 3.8 happy\n  } & ServerErrorData;\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<ErrorCode, ErrorParams>(\n  SERVICE,\n  SERVICE_NAME,\n  ERROR_DESCRIPTION_MAP\n);\n\nexport interface ServerErrorData {\n  serverCode: number;\n  serverMessage: string;\n  serverStatus: string;\n}\n\nexport type ServerError = FirebaseError & { customData: ServerErrorData };\n\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nexport function isServerError(error: unknown): error is ServerError {\n  return (\n    error instanceof FirebaseError &&\n    error.code.includes(ErrorCode.REQUEST_FAILED)\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseError } from '@firebase/util';\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport {\n  INSTALLATIONS_API_URL,\n  INTERNAL_AUTH_VERSION\n} from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function getInstallationsEndpoint({ projectId }: AppConfig): string {\n  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\n\nexport function extractAuthTokenInfoFromResponse(\n  response: GenerateAuthTokenResponse\n): CompletedAuthToken {\n  return {\n    token: response.token,\n    requestStatus: RequestStatus.COMPLETED,\n    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n    creationTime: Date.now()\n  };\n}\n\nexport async function getErrorFromResponse(\n  requestName: string,\n  response: Response\n): Promise<FirebaseError> {\n  const responseJson: ErrorResponse = await response.json();\n  const errorData = responseJson.error;\n  return ERROR_FACTORY.create(ErrorCode.REQUEST_FAILED, {\n    requestName,\n    serverCode: errorData.code,\n    serverMessage: errorData.message,\n    serverStatus: errorData.status\n  });\n}\n\nexport function getHeaders({ apiKey }: AppConfig): Headers {\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': apiKey\n  });\n}\n\nexport function getHeadersWithAuth(\n  appConfig: AppConfig,\n  { refreshToken }: RegisteredInstallationEntry\n): Headers {\n  const headers = getHeaders(appConfig);\n  headers.append('Authorization', getAuthorizationHeader(refreshToken));\n  return headers;\n}\n\nexport interface ErrorResponse {\n  error: {\n    code: number;\n    message: string;\n    status: string;\n  };\n}\n\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nexport async function retryIfServerError(\n  fn: () => Promise<Response>\n): Promise<Response> {\n  const result = await fn();\n\n  if (result.status >= 500 && result.status < 600) {\n    // Internal Server Error. Retry request.\n    return fn();\n  }\n\n  return result;\n}\n\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn: string): number {\n  // This works because the server will never respond with fractions of a second.\n  return Number(responseExpiresIn.replace('s', '000'));\n}\n\nfunction getAuthorizationHeader(refreshToken: string): string {\n  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CreateInstallationResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { INTERNAL_AUTH_VERSION, PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeaders,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function createInstallationRequest(\n  appConfig: AppConfig,\n  { fid }: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  const endpoint = getInstallationsEndpoint(appConfig);\n\n  const headers = getHeaders(appConfig);\n  const body = {\n    fid,\n    authVersion: INTERNAL_AUTH_VERSION,\n    appId: appConfig.appId,\n    sdkVersion: PACKAGE_VERSION\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: CreateInstallationResponse = await response.json();\n    const registeredInstallationEntry: RegisteredInstallationEntry = {\n      fid: responseValue.fid || fid,\n      registrationStatus: RequestStatus.COMPLETED,\n      refreshToken: responseValue.refreshToken,\n      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n    };\n    return registeredInstallationEntry;\n  } else {\n    throw await getErrorFromResponse('Create Installation', response);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Returns a promise that resolves after given time passes. */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bufferToBase64UrlSafe } from './buffer-to-base64-url-safe';\n\nexport const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nexport const INVALID_FID = '';\n\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nexport function generateFid(): string {\n  try {\n    // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n    // bytes. our implementation generates a 17 byte array instead.\n    const fidByteArray = new Uint8Array(17);\n    const crypto =\n      self.crypto || ((self as unknown) as { msCrypto: Crypto }).msCrypto;\n    crypto.getRandomValues(fidByteArray);\n\n    // Replace the first 4 random bits with the constant FID header of 0b0111.\n    fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n\n    const fid = encode(fidByteArray);\n\n    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n  } catch {\n    // FID generation errored\n    return INVALID_FID;\n  }\n}\n\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray: Uint8Array): string {\n  const b64String = bufferToBase64UrlSafe(fidByteArray);\n\n  // Remove the 23rd character that was added because of the extra 4 bits at the\n  // end of our 17 byte array, and the '=' padding.\n  return b64String.substr(0, 22);\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function bufferToBase64UrlSafe(array: Uint8Array): string {\n  const b64 = btoa(String.fromCharCode(...array));\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\n\n/** Returns a string key that can be used to identify the app. */\nexport function getKey(appConfig: AppConfig): string {\n  return `${appConfig.appName}!${appConfig.appId}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getKey } from '../util/get-key';\nimport { AppConfig } from '../interfaces/app-config';\nimport { IdChangeCallbackFn } from '../functions';\n\nconst fidChangeCallbacks: Map<string, Set<IdChangeCallbackFn>> = new Map();\n\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */\nexport function fidChanged(appConfig: AppConfig, fid: string): void {\n  const key = getKey(appConfig);\n\n  callFidChangeCallbacks(key, fid);\n  broadcastFidChange(key, fid);\n}\n\nexport function addCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  // Open the broadcast channel if it's not already open,\n  // to be able to listen to change events from other tabs.\n  getBroadcastChannel();\n\n  const key = getKey(appConfig);\n\n  let callbackSet = fidChangeCallbacks.get(key);\n  if (!callbackSet) {\n    callbackSet = new Set();\n    fidChangeCallbacks.set(key, callbackSet);\n  }\n  callbackSet.add(callback);\n}\n\nexport function removeCallback(\n  appConfig: AppConfig,\n  callback: IdChangeCallbackFn\n): void {\n  const key = getKey(appConfig);\n\n  const callbackSet = fidChangeCallbacks.get(key);\n\n  if (!callbackSet) {\n    return;\n  }\n\n  callbackSet.delete(callback);\n  if (callbackSet.size === 0) {\n    fidChangeCallbacks.delete(key);\n  }\n\n  // Close broadcast channel if there are no more callbacks.\n  closeBroadcastChannel();\n}\n\nfunction callFidChangeCallbacks(key: string, fid: string): void {\n  const callbacks = fidChangeCallbacks.get(key);\n  if (!callbacks) {\n    return;\n  }\n\n  for (const callback of callbacks) {\n    callback(fid);\n  }\n}\n\nfunction broadcastFidChange(key: string, fid: string): void {\n  const channel = getBroadcastChannel();\n  if (channel) {\n    channel.postMessage({ key, fid });\n  }\n  closeBroadcastChannel();\n}\n\nlet broadcastChannel: BroadcastChannel | null = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\nfunction getBroadcastChannel(): BroadcastChannel | null {\n  if (!broadcastChannel && 'BroadcastChannel' in self) {\n    broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\n    broadcastChannel.onmessage = e => {\n      callFidChangeCallbacks(e.data.key, e.data.fid);\n    };\n  }\n  return broadcastChannel;\n}\n\nfunction closeBroadcastChannel(): void {\n  if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n    broadcastChannel.close();\n    broadcastChannel = null;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DB, openDb } from 'idb';\nimport { AppConfig } from '../interfaces/app-config';\nimport { InstallationEntry } from '../interfaces/installation-entry';\nimport { getKey } from '../util/get-key';\nimport { fidChanged } from './fid-changed';\n\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\n\nlet dbPromise: Promise<DB> | null = null;\nfunction getDbPromise(): Promise<DB> {\n  if (!dbPromise) {\n    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, upgradeDB => {\n      // We don't use 'break' in this switch statement, the fall-through\n      // behavior is what we want, because if there are multiple versions between\n      // the old version and the current version, we want ALL the migrations\n      // that correspond to those versions to run, not only the last one.\n      // eslint-disable-next-line default-case\n      switch (upgradeDB.oldVersion) {\n        case 0:\n          upgradeDB.createObjectStore(OBJECT_STORE_NAME);\n      }\n    });\n  }\n  return dbPromise;\n}\n\n/** Gets record(s) from the objectStore that match the given key. */\nexport async function get(\n  appConfig: AppConfig\n): Promise<InstallationEntry | undefined> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  return db\n    .transaction(OBJECT_STORE_NAME)\n    .objectStore(OBJECT_STORE_NAME)\n    .get(key);\n}\n\n/** Assigns or overwrites the record for the given key with the given value. */\nexport async function set<ValueType extends InstallationEntry>(\n  appConfig: AppConfig,\n  value: ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue = await objectStore.get(key);\n  await objectStore.put(value, key);\n  await tx.complete;\n\n  if (!oldValue || oldValue.fid !== value.fid) {\n    fidChanged(appConfig, value.fid);\n  }\n\n  return value;\n}\n\n/** Removes record(s) from the objectStore that match the given key. */\nexport async function remove(appConfig: AppConfig): Promise<void> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n  await tx.complete;\n}\n\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nexport async function update<ValueType extends InstallationEntry | undefined>(\n  appConfig: AppConfig,\n  updateFn: (previousValue: InstallationEntry | undefined) => ValueType\n): Promise<ValueType> {\n  const key = getKey(appConfig);\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  const store = tx.objectStore(OBJECT_STORE_NAME);\n  const oldValue: InstallationEntry | undefined = await store.get(key);\n  const newValue = updateFn(oldValue);\n\n  if (newValue === undefined) {\n    await store.delete(key);\n  } else {\n    await store.put(newValue, key);\n  }\n  await tx.complete;\n\n  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n    fidChanged(appConfig, newValue.fid);\n  }\n\n  return newValue;\n}\n\nexport async function clear(): Promise<void> {\n  const db = await getDbPromise();\n  const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n  await tx.objectStore(OBJECT_STORE_NAME).clear();\n  await tx.complete;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport {\n  _FirebaseNamespace,\n  FirebaseService\n} from '@firebase/app-types/private';\nimport { Component, ComponentType } from '@firebase/component';\nimport { FirebaseInstallations } from '@firebase/installations-types';\nimport {\n  deleteInstallation,\n  getId,\n  getToken,\n  IdChangeCallbackFn,\n  IdChangeUnsubscribeFn,\n  onIdChange\n} from './functions';\nimport { extractAppConfig } from './helpers/extract-app-config';\nimport { FirebaseDependencies } from './interfaces/firebase-dependencies';\n\nimport { name, version } from '../package.json';\n\nexport function registerInstallations(instance: _FirebaseNamespace): void {\n  const installationsName = 'installations';\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      installationsName,\n      container => {\n        const app = container.getProvider('app').getImmediate();\n\n        // Throws if app isn't configured properly.\n        const appConfig = extractAppConfig(app);\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        const dependencies: FirebaseDependencies = {\n          appConfig,\n          platformLoggerProvider\n        };\n\n        const installations: FirebaseInstallations & FirebaseService = {\n          app,\n          getId: () => getId(dependencies),\n          getToken: (forceRefresh?: boolean) =>\n            getToken(dependencies, forceRefresh),\n          delete: () => deleteInstallation(dependencies),\n          onIdChange: (callback: IdChangeCallbackFn): IdChangeUnsubscribeFn =>\n            onIdChange(dependencies, callback)\n        };\n        return installations;\n      },\n      ComponentType.PUBLIC\n    )\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterInstallations(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerInstallations`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    installations(app?: FirebaseApp): FirebaseInstallations;\n  }\n  interface FirebaseApp {\n    installations(): FirebaseInstallations;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createInstallationRequest } from '../api/create-installation-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport {\n  InProgressInstallationEntry,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { generateFid, INVALID_FID } from './generate-fid';\nimport { remove, set, update } from './idb-manager';\n\nexport interface InstallationEntryWithRegistrationPromise {\n  installationEntry: InstallationEntry;\n  /** Exist iff the installationEntry is not registered. */\n  registrationPromise?: Promise<RegisteredInstallationEntry>;\n}\n\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nexport async function getInstallationEntry(\n  appConfig: AppConfig\n): Promise<InstallationEntryWithRegistrationPromise> {\n  let registrationPromise: Promise<RegisteredInstallationEntry> | undefined;\n\n  const installationEntry = await update(appConfig, oldEntry => {\n    const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n    const entryWithPromise = triggerRegistrationIfNecessary(\n      appConfig,\n      installationEntry\n    );\n    registrationPromise = entryWithPromise.registrationPromise;\n    return entryWithPromise.installationEntry;\n  });\n\n  if (installationEntry.fid === INVALID_FID) {\n    // FID generation failed. Waiting for the FID from the server.\n    return { installationEntry: await registrationPromise! };\n  }\n\n  return {\n    installationEntry,\n    registrationPromise\n  };\n}\n\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(\n  oldEntry: InstallationEntry | undefined\n): InstallationEntry {\n  const entry: InstallationEntry = oldEntry || {\n    fid: generateFid(),\n    registrationStatus: RequestStatus.NOT_STARTED\n  };\n\n  return clearTimedOutRequest(entry);\n}\n\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(\n  appConfig: AppConfig,\n  installationEntry: InstallationEntry\n): InstallationEntryWithRegistrationPromise {\n  if (installationEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n    if (!navigator.onLine) {\n      // Registration required but app is offline.\n      const registrationPromiseWithError = Promise.reject(\n        ERROR_FACTORY.create(ErrorCode.APP_OFFLINE)\n      );\n      return {\n        installationEntry,\n        registrationPromise: registrationPromiseWithError\n      };\n    }\n\n    // Try registering. Change status to IN_PROGRESS.\n    const inProgressEntry: InProgressInstallationEntry = {\n      fid: installationEntry.fid,\n      registrationStatus: RequestStatus.IN_PROGRESS,\n      registrationTime: Date.now()\n    };\n    const registrationPromise = registerInstallation(\n      appConfig,\n      inProgressEntry\n    );\n    return { installationEntry: inProgressEntry, registrationPromise };\n  } else if (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS\n  ) {\n    return {\n      installationEntry,\n      registrationPromise: waitUntilFidRegistration(appConfig)\n    };\n  } else {\n    return { installationEntry };\n  }\n}\n\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(\n  appConfig: AppConfig,\n  installationEntry: InProgressInstallationEntry\n): Promise<RegisteredInstallationEntry> {\n  try {\n    const registeredInstallationEntry = await createInstallationRequest(\n      appConfig,\n      installationEntry\n    );\n    return set(appConfig, registeredInstallationEntry);\n  } catch (e) {\n    if (isServerError(e) && e.customData.serverCode === 409) {\n      // Server returned a \"FID can not be used\" error.\n      // Generate a new ID next time.\n      await remove(appConfig);\n    } else {\n      // Registration failed. Set FID as not registered.\n      await set(appConfig, {\n        fid: installationEntry.fid,\n        registrationStatus: RequestStatus.NOT_STARTED\n      });\n    }\n    throw e;\n  }\n}\n\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry: InstallationEntry = await updateInstallationRequest(appConfig);\n  while (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n    // createInstallation request still in progress.\n    await sleep(100);\n\n    entry = await updateInstallationRequest(appConfig);\n  }\n\n  if (entry.registrationStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    const {\n      installationEntry,\n      registrationPromise\n    } = await getInstallationEntry(appConfig);\n\n    if (registrationPromise) {\n      return registrationPromise;\n    } else {\n      // if there is no registrationPromise, entry is registered.\n      return installationEntry as RegisteredInstallationEntry;\n    }\n  }\n\n  return entry;\n}\n\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(\n  appConfig: AppConfig\n): Promise<InstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!oldEntry) {\n      throw ERROR_FACTORY.create(ErrorCode.INSTALLATION_NOT_FOUND);\n    }\n    return clearTimedOutRequest(oldEntry);\n  });\n}\n\nfunction clearTimedOutRequest(entry: InstallationEntry): InstallationEntry {\n  if (hasInstallationRequestTimedOut(entry)) {\n    return {\n      fid: entry.fid,\n      registrationStatus: RequestStatus.NOT_STARTED\n    };\n  }\n\n  return entry;\n}\n\nfunction hasInstallationRequestTimedOut(\n  installationEntry: InstallationEntry\n): boolean {\n  return (\n    installationEntry.registrationStatus === RequestStatus.IN_PROGRESS &&\n    installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GenerateAuthTokenResponse } from '../interfaces/api-response';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  CompletedAuthToken,\n  RegisteredInstallationEntry\n} from '../interfaces/installation-entry';\nimport { PACKAGE_VERSION } from '../util/constants';\nimport {\n  extractAuthTokenInfoFromResponse,\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function generateAuthTokenRequest(\n  { appConfig, platformLoggerProvider }: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers.append('x-firebase-client', platformLogger.getPlatformInfoString());\n  }\n\n  const body = {\n    installation: {\n      sdkVersion: PACKAGE_VERSION\n    }\n  };\n\n  const request: RequestInit = {\n    method: 'POST',\n    headers,\n    body: JSON.stringify(body)\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (response.ok) {\n    const responseValue: GenerateAuthTokenResponse = await response.json();\n    const completedAuthToken: CompletedAuthToken = extractAuthTokenInfoFromResponse(\n      responseValue\n    );\n    return completedAuthToken;\n  } else {\n    throw await getErrorFromResponse('Generate Auth Token', response);\n  }\n}\n\nfunction getGenerateAuthTokenEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { generateAuthTokenRequest } from '../api/generate-auth-token-request';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport {\n  AuthToken,\n  CompletedAuthToken,\n  InProgressAuthToken,\n  InstallationEntry,\n  RegisteredInstallationEntry,\n  RequestStatus\n} from '../interfaces/installation-entry';\nimport { PENDING_TIMEOUT_MS, TOKEN_EXPIRATION_BUFFER } from '../util/constants';\nimport { ERROR_FACTORY, ErrorCode, isServerError } from '../util/errors';\nimport { sleep } from '../util/sleep';\nimport { remove, set, update } from './idb-manager';\n\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nexport async function refreshAuthToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<CompletedAuthToken> {\n  let tokenPromise: Promise<CompletedAuthToken> | undefined;\n  const entry = await update(dependencies.appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n      // There is a valid token in the DB.\n      return oldEntry;\n    } else if (oldAuthToken.requestStatus === RequestStatus.IN_PROGRESS) {\n      // There already is a token request in progress.\n      tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);\n      return oldEntry;\n    } else {\n      // No token or token expired.\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      }\n\n      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n      tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);\n      return inProgressEntry;\n    }\n  });\n\n  const authToken = tokenPromise\n    ? await tokenPromise\n    : (entry.authToken as CompletedAuthToken);\n  return authToken;\n}\n\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(\n  dependencies: FirebaseDependencies,\n  forceRefresh: boolean\n): Promise<CompletedAuthToken> {\n  // Unfortunately, there is no way of reliably observing when a value in\n  // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n  // so we need to poll.\n\n  let entry = await updateAuthTokenRequest(dependencies.appConfig);\n  while (entry.authToken.requestStatus === RequestStatus.IN_PROGRESS) {\n    // generateAuthToken still in progress.\n    await sleep(100);\n\n    entry = await updateAuthTokenRequest(dependencies.appConfig);\n  }\n\n  const authToken = entry.authToken;\n  if (authToken.requestStatus === RequestStatus.NOT_STARTED) {\n    // The request timed out or failed in a different call. Try again.\n    return refreshAuthToken(dependencies, forceRefresh);\n  } else {\n    return authToken;\n  }\n}\n\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(\n  appConfig: AppConfig\n): Promise<RegisteredInstallationEntry> {\n  return update(appConfig, oldEntry => {\n    if (!isEntryRegistered(oldEntry)) {\n      throw ERROR_FACTORY.create(ErrorCode.NOT_REGISTERED);\n    }\n\n    const oldAuthToken = oldEntry.authToken;\n    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n      return {\n        ...oldEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n    }\n\n    return oldEntry;\n  });\n}\n\nasync function fetchAuthTokenFromServer(\n  dependencies: FirebaseDependencies,\n  installationEntry: RegisteredInstallationEntry\n): Promise<CompletedAuthToken> {\n  try {\n    const authToken = await generateAuthTokenRequest(\n      dependencies,\n      installationEntry\n    );\n    const updatedInstallationEntry: RegisteredInstallationEntry = {\n      ...installationEntry,\n      authToken\n    };\n    await set(dependencies.appConfig, updatedInstallationEntry);\n    return authToken;\n  } catch (e) {\n    if (\n      isServerError(e) &&\n      (e.customData.serverCode === 401 || e.customData.serverCode === 404)\n    ) {\n      // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n      // Generate a new ID next time.\n      await remove(dependencies.appConfig);\n    } else {\n      const updatedInstallationEntry: RegisteredInstallationEntry = {\n        ...installationEntry,\n        authToken: { requestStatus: RequestStatus.NOT_STARTED }\n      };\n      await set(dependencies.appConfig, updatedInstallationEntry);\n    }\n    throw e;\n  }\n}\n\nfunction isEntryRegistered(\n  installationEntry: InstallationEntry | undefined\n): installationEntry is RegisteredInstallationEntry {\n  return (\n    installationEntry !== undefined &&\n    installationEntry.registrationStatus === RequestStatus.COMPLETED\n  );\n}\n\nfunction isAuthTokenValid(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.COMPLETED &&\n    !isAuthTokenExpired(authToken)\n  );\n}\n\nfunction isAuthTokenExpired(authToken: CompletedAuthToken): boolean {\n  const now = Date.now();\n  return (\n    now < authToken.creationTime ||\n    authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER\n  );\n}\n\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(\n  oldEntry: RegisteredInstallationEntry\n): RegisteredInstallationEntry {\n  const inProgressAuthToken: InProgressAuthToken = {\n    requestStatus: RequestStatus.IN_PROGRESS,\n    requestTime: Date.now()\n  };\n  return {\n    ...oldEntry,\n    authToken: inProgressAuthToken\n  };\n}\n\nfunction hasAuthTokenRequestTimedOut(authToken: AuthToken): boolean {\n  return (\n    authToken.requestStatus === RequestStatus.IN_PROGRESS &&\n    authToken.requestTime + PENDING_TIMEOUT_MS < Date.now()\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { AppConfig } from '../interfaces/app-config';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getToken(\n  dependencies: FirebaseDependencies,\n  forceRefresh = false\n): Promise<string> {\n  await completeInstallationRegistration(dependencies.appConfig);\n\n  // At this point we either have a Registered Installation in the DB, or we've\n  // already thrown an error.\n  const authToken = await refreshAuthToken(dependencies, forceRefresh);\n  return authToken.token;\n}\n\nasync function completeInstallationRegistration(\n  appConfig: AppConfig\n): Promise<void> {\n  const { registrationPromise } = await getInstallationEntry(appConfig);\n\n  if (registrationPromise) {\n    // A createInstallation request is in progress. Wait until it finishes.\n    await registrationPromise;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig } from '../interfaces/app-config';\nimport { RegisteredInstallationEntry } from '../interfaces/installation-entry';\nimport {\n  getErrorFromResponse,\n  getHeadersWithAuth,\n  getInstallationsEndpoint,\n  retryIfServerError\n} from './common';\n\nexport async function deleteInstallationRequest(\n  appConfig: AppConfig,\n  installationEntry: RegisteredInstallationEntry\n): Promise<void> {\n  const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n\n  const headers = getHeadersWithAuth(appConfig, installationEntry);\n  const request: RequestInit = {\n    method: 'DELETE',\n    headers\n  };\n\n  const response = await retryIfServerError(() => fetch(endpoint, request));\n  if (!response.ok) {\n    throw await getErrorFromResponse('Delete Installation', response);\n  }\n}\n\nfunction getDeleteEndpoint(\n  appConfig: AppConfig,\n  { fid }: RegisteredInstallationEntry\n): string {\n  return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { addCallback, removeCallback } from '../helpers/fid-changed';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport type IdChangeCallbackFn = (installationId: string) => void;\nexport type IdChangeUnsubscribeFn = () => void;\n\n/**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n */\nexport function onIdChange(\n  { appConfig }: FirebaseDependencies,\n  callback: IdChangeCallbackFn\n): IdChangeUnsubscribeFn {\n  addCallback(appConfig, callback);\n\n  return () => {\n    removeCallback(appConfig, callback);\n  };\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseOptions } from '@firebase/app-types';\nimport { FirebaseError } from '@firebase/util';\nimport { AppConfig } from '../interfaces/app-config';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport function extractAppConfig(app: FirebaseApp): AppConfig {\n  if (!app || !app.options) {\n    throw getMissingValueError('App Configuration');\n  }\n\n  if (!app.name) {\n    throw getMissingValueError('App Name');\n  }\n\n  // Required app config keys\n  const configKeys: Array<keyof FirebaseOptions> = [\n    'projectId',\n    'apiKey',\n    'appId'\n  ];\n\n  for (const keyName of configKeys) {\n    if (!app.options[keyName]) {\n      throw getMissingValueError(keyName);\n    }\n  }\n\n  return {\n    appName: app.name,\n    projectId: app.options.projectId!,\n    apiKey: app.options.apiKey!,\n    appId: app.options.appId!\n  };\n}\n\nfunction getMissingValueError(valueName: string): FirebaseError {\n  return ERROR_FACTORY.create(ErrorCode.MISSING_APP_CONFIG_VALUES, {\n    valueName\n  });\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getInstallationEntry } from '../helpers/get-installation-entry';\nimport { refreshAuthToken } from '../helpers/refresh-auth-token';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\n\nexport async function getId(\n  dependencies: FirebaseDependencies\n): Promise<string> {\n  const { installationEntry, registrationPromise } = await getInstallationEntry(\n    dependencies.appConfig\n  );\n\n  if (registrationPromise) {\n    registrationPromise.catch(console.error);\n  } else {\n    // If the installation is already registered, update the authentication\n    // token if needed.\n    refreshAuthToken(dependencies).catch(console.error);\n  }\n\n  return installationEntry.fid;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deleteInstallationRequest } from '../api/delete-installation-request';\nimport { remove, update } from '../helpers/idb-manager';\nimport { FirebaseDependencies } from '../interfaces/firebase-dependencies';\nimport { RequestStatus } from '../interfaces/installation-entry';\nimport { ERROR_FACTORY, ErrorCode } from '../util/errors';\n\nexport async function deleteInstallation(\n  dependencies: FirebaseDependencies\n): Promise<void> {\n  const { appConfig } = dependencies;\n\n  const entry = await update(appConfig, oldEntry => {\n    if (oldEntry && oldEntry.registrationStatus === RequestStatus.NOT_STARTED) {\n      // Delete the unregistered entry without sending a deleteInstallation request.\n      return undefined;\n    }\n    return oldEntry;\n  });\n\n  if (entry) {\n    if (entry.registrationStatus === RequestStatus.IN_PROGRESS) {\n      // Can't delete while trying to register.\n      throw ERROR_FACTORY.create(ErrorCode.DELETE_PENDING_REGISTRATION);\n    } else if (entry.registrationStatus === RequestStatus.COMPLETED) {\n      if (!navigator.onLine) {\n        throw ERROR_FACTORY.create(ErrorCode.APP_OFFLINE);\n      } else {\n        await deleteInstallationRequest(appConfig, entry);\n        await remove(appConfig);\n      }\n    }\n  }\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.idb = {}));\n}(this, function (exports) { 'use strict';\n\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      // Don't create iterateKeyCursor if openKeyCursor doesn't exist.\n      if (!(funcName in Constructor.prototype)) return;\n\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  function openDb(name, version, upgradeCallback) {\n    var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n    var request = p.request;\n\n    if (request) {\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n    }\n\n    return p.then(function(db) {\n      return new DB(db);\n    });\n  }\n\n  function deleteDb(name) {\n    return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n  }\n\n  exports.openDb = openDb;\n  exports.deleteDb = deleteDb;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"sourceRoot":""}